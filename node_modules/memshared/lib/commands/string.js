"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("../");
var key_1 = require("./key");
/*
 * GET key
 * Get the value of a key
 */
function get(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("get", callback, key);
    }
    else {
        return _1.store[key];
    }
}
exports.get = get;
/*
 * SET key value [EX seconds] [PX milliseconds] [NX|XX]
 * Set the string value of a key
 */
function set(key, value, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("set", callback, key, value);
    }
    else {
        _1.store[key] = value;
        return "OK";
    }
}
exports.set = set;
/*
 * APPEND key value
 * Append a value to a key
 */
function append() {
}
exports.append = append;
/*
 * BITCOUNT key [start end]
 * Count set bits in a string
 */
function bitcount() {
}
exports.bitcount = bitcount;
/*
 * BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]
 * Perform arbitrary bitfield integer operations on strings
 */
function bitfield() {
}
exports.bitfield = bitfield;
/*
 * BITOP operation destkey key [key ...]
 * Perform bitwise operations between strings
 */
function bitop() {
}
exports.bitop = bitop;
/*
 * BITPOS key bit [start] [end]
 * Find first bit set or clear in a string
 */
function bitpos() {
}
exports.bitpos = bitpos;
/*
 * DECR key
 * Decrement the integer value of a key by one
 */
function decr(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("decr", callback, key);
    }
    else {
        if (!_1.store[key]) {
            _1.store[key] = 0;
        }
        return (--_1.store[key]);
    }
}
exports.decr = decr;
/*
 * DECRBY key decrement
 * Decrement the integer value of a key by the given number
 */
function decrby(key, value, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("decrby", callback, key, value);
    }
    else {
        if (!_1.store[key]) {
            _1.store[key] = 0;
        }
        _1.store[key] -= value;
        return _1.store[key];
    }
}
exports.decrby = decrby;
/*
 * GETBIT key offset
 * Returns the bit value at offset in the string value stored at key
 */
function getbit() {
}
exports.getbit = getbit;
/*
 * GETRANGE key start end
 * Get a substring of the string stored at a key
 */
function getrange() {
}
exports.getrange = getrange;
/*
 * GETSET key value
 * Set the string value of a key and return its old value
 */
function getset() {
}
exports.getset = getset;
/*
 * INCR key
 * Increment the integer value of a key by one
 */
function incr(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("incr", callback, key);
    }
    else {
        if (!_1.store[key]) {
            _1.store[key] = 0;
        }
        return ++_1.store[key];
    }
}
exports.incr = incr;
/*
 * INCRBY key increment
 * Increment the integer value of a key by the given amount
 */
function incrby(key, value, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("incrby", callback, key, value);
    }
    else {
        if (!_1.store[key]) {
            _1.store[key] = 0;
        }
        _1.store[key] += value;
        return _1.store[key];
    }
}
exports.incrby = incrby;
/*
 * INCRBYFLOAT key increment
 * Increment the float value of a key by the given amount
 */
function incrbyfloat() {
}
exports.incrbyfloat = incrbyfloat;
/*
 * MGET key [key ...]
 * Get the values of all the given keys
 */
function mget(keys, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("mget", callback, keys);
    }
    else {
        return keys.map(function (k) { return get(k, undefined); });
    }
}
exports.mget = mget;
/*
 * MSET key value [key value ...]
 * Set multiple keys to multiple values
 */
function mset() {
}
exports.mset = mset;
/*
 * MSETNX key value [key value ...]
 * Set multiple keys to multiple values, only if none of the keys exist
 */
function msetnx() {
}
exports.msetnx = msetnx;
/*
 * PSETEX key milliseconds value
 * Set the value and expiration in milliseconds of a key
 */
function psetex() {
}
exports.psetex = psetex;
/*
 * SETBIT key offset value
 * Sets or clears the bit at offset in the string value stored at key
 */
function setbit() {
}
exports.setbit = setbit;
/*
 * SETEX key seconds value
 * Set the value and expiration of a key
 */
var timeouts = {};
function setex(key, seconds, value, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("setex", callback, key, seconds, value);
    }
    else {
        set(key, value, undefined);
        // ensure previous timeout is cleared before setting a new one
        if (timeouts[key]) {
            clearTimeout(timeouts[key]);
        }
        // enqueue to delete after timeout in seconds.
        timeouts[key] = setTimeout(function () {
            key_1.del(key);
            delete timeouts[key];
        }, seconds * 1000);
        return "OK";
    }
}
exports.setex = setex;
/*
 * SETNX key value
 * Set the value of a key, only if the key does not exist
 */
function setnx() {
}
exports.setnx = setnx;
/*
 * SETRANGE key offset value
 * Overwrite part of a string at key starting at the specified offset
 */
function setrange() {
}
exports.setrange = setrange;
/*
 * STRLEN key
 * Get the length of the value stored in a key
 */
function strlen(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("strlen", callback, key);
    }
    else {
        return (_1.store[key] || "").length;
    }
}
exports.strlen = strlen;
